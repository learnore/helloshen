# -*- coding: utf-8 -*-
"""
-------------------------------------------------
  IDE         : PyCharm
  File Name   : iadd_add
  Description : __iadd__ 实现的是 a += b
                __add__  实现的是 a = a + b

                根据以上规则，都是对 a 进行扩充，这里就应该注意，Python 的 可变序列 & 不可变序列
                可变序列：列表、集合、字典
                不可变序列：元组、字符串

                __iadd__ +=     __add__ + 后赋值
                __imul__ *=     __mul__ * 后赋值
  Author      : chenyushencc@gmail.com
  date        : 2022/4/26 7:33
-------------------------------------------------
"""


if __name__ == '__main__':
    """
    * 可变序列的 += *= ... 的内存地址都
    * 不会改变
    """
    l = [1, 2, 3]
    print(id(l))
    l += [2]
    print(id(l))    # 不会改变地址的，而是改变内存中的值，或者是扩展内存空间

    """
    * 不可变序列 += *= ... 的内存地址都
    * 会改变
    """
    t = (1, 2, 3)
    print(id(t))
    t *= 2
    print(id(t))

    """
    * 一个关于+=的谜题
    * Python 3.10 估计已经解决了这个 BUG
    * 
    * 3 个教训：
    * 不要把可变对象放在元组里面。
    * 增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。（Python 3.10 估计已经解决了这个 BUG，直接抛出 Typeerror）
    * 查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。
    """
    # t = (1, 2, [30, 40])
    # t[2] += [50, 60]
    # print(t)

    import dis
    dis.dis('s[a] += b')        # 查看 Python 的字节码，了解代码背后的运行机制
